# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19LTCWKdRS3t96-k-9H-YjCENEIeXcw7I

## Proyecto 2: Filtro y clasificación de imagénes
Este proyecto toma su origen en la tarea de clasificar una serie de imagénes diferentes en las cuales hay perros y gatos. Para la tarea del procesamiento de las imagénes se redimensionaron a un tamaño de 150x150 píxeles y se convirtieron a escala de grises. Luego se aplica un filtro de blanco y negro para mejorar los contrastes de los bordes. Para la red neuronal convolucional se optó por  dos capas convolucionales con activación ReLU, seguidas de capas de max pooling, una capa densa intermedia y una capa de salida con una única neurona con activación sigmoide para la clasificación binaria. El modelo fue entrenado utilizando la función de pérdida binary_crossentropy, adecuada para problemas con dos clases, y el optimizador Adam, reconocido por su eficiencia y velocidad de convergencia.
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import Adam

# Parámetros
img_width = 200
img_height = 200

# escala de grises
def load_images_grayscale(cat_folder, dog_folder):
    images = []
    labels = []

    for label, folder in enumerate([cat_folder, dog_folder]):
        for filename in os.listdir(folder):
            if filename.lower().endswith(('.jpg', '.jpeg', '.png')):
                path = os.path.join(folder, filename)
                img = cv2.imread(path)
                if img is not None:
                    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                    resized = cv2.resize(gray, (img_width, img_height))
                    norm = resized.astype('float32') / 255.0
                    images.append(norm.reshape(img_height, img_width, 1))  # canal único
                    labels.append(label)  # 0 para gato, 1 para perro

    return np.array(images), np.array(labels)

# Rutas
train_cat_dir = "/content/drive/MyDrive/test/cats"
train_dog_dir = "/content/drive/MyDrive/test/dogs"
test_cat_dir = "/content/drive/MyDrive/train/cats"
test_dog_dir = "/content/drive/MyDrive/train/dogs"


X_train, y_train = load_images_grayscale(train_cat_dir, train_dog_dir)
X_test, y_test = load_images_grayscale(test_cat_dir, test_dog_dir)

# Modelo
model = Sequential()
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(img_height, img_width, 1)))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(1, activation='sigmoid'))


model.compile(optimizer=Adam(learning_rate=0.0001), loss='binary_crossentropy', metrics=['accuracy'])

# Entrenamiento
history = model.fit(X_train, y_train, epochs=30, batch_size=10, validation_data=(X_test, y_test))

# Evaluación
test_loss, test_acc = model.evaluate(X_test, y_test, verbose=0)
print(f"Precisión en el test: {test_acc * 100:.2f}%")

# Gráficas
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Entrenamiento')
plt.plot(history.history['val_accuracy'], label='Validación')
plt.title('Precisión')
plt.xlabel('Épocas')
plt.ylabel('Precisión')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Entrenamiento')
plt.plot(history.history['val_loss'], label='Validación')
plt.title('Pérdida')
plt.xlabel('Épocas')
plt.ylabel('Pérdida')
plt.legend()

plt.show()

# Predicciones
predictions = model.predict(X_test)
predicted_classes = (predictions > 0.5).astype("int32")


plt.figure(figsize=(15, 10))
for i in range(15):
    plt.subplot(3, 5, i+1)
    plt.imshow(X_test[i].reshape(img_height, img_width), cmap='gray')
    color = 'green' if predicted_classes[i] == y_test[i] else 'red'
    plt.title(f"Pred: {'Perro' if predicted_classes[i]==1 else 'Gato'}\nReal: {'Perro' if y_test[i]==1 else 'Gato'}", color=color)
    plt.axis('off')
plt.tight_layout()
plt.show()